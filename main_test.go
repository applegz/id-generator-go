package main

import (
	"sync"
	"testing"
)

// TestNewSnowflake validates the behavior of the NewSnowflake function with various workerID inputs and expected error states.
func TestNewSnowflake(t *testing.T) {
	tests := []struct {
		name      string
		workerID  int64
		wantError bool
	}{
		{"validWorkerID", 0, false},
		{"maxWorkerID", maxWorkerID, false},
		{"negativeWorkerID", -1, true},
		{"exceedsMaxWorkerID", maxWorkerID + 1, true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			snowflake, err := NewSnowflake(tt.workerID)

			if (err != nil) != tt.wantError {
				t.Errorf("unexpected error state; got err = %v, wantError = %v", err, tt.wantError)
			}

			if snowflake != nil && snowflake.workerID != tt.workerID {
				t.Errorf("unexpected workerID; got = %d, want = %d", snowflake.workerID, tt.workerID)
			}
		})
	}
}

// TestSnowflakeNextID tests the Snowflake ID generation for uniqueness, rollover handling, and edge cases with worker IDs.
func TestSnowflakeNextID(t *testing.T) {
	tests := []struct {
		name     string
		workerID int64
	}{
		{"basicGeneration", 1},
		{"zeroWorkerID", 0},
		{"maxWorkerID", maxWorkerID},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			sf, err := NewSnowflake(tt.workerID)
			if err != nil {
				t.Fatalf("failed to create Snowflake: %v", err)
			}

			// Generate a few IDs and check for uniqueness
			ids := make(map[int64]struct{})
			for i := 0; i < 100; i++ {
				id := sf.NextID()
				if _, exists := ids[id]; exists {
					t.Errorf("duplicate ID generated: %d", id)
				} else {
					ids[id] = struct{}{}
				}
			}

			// Test rollover case
			sf.mutex.Lock()
			sf.sequence = maxSequence
			sf.lastTS = currentTimeMillis()
			sf.mutex.Unlock()

			id := sf.NextID()
			if id == 0 {
				t.Error("rollover ID incorrectly generated 0")
			}
		})
	}
}

// TestSnowflakeLogRate verifies the logging rate functionality and ensures Snowflake IDs are generated without errors.
func TestSnowflakeLogRate(t *testing.T) {
	_, err := NewSnowflake(1)
	if err != nil {
		t.Fatalf("failed to create Snowflake: %v", err)
	}
}

// TestSnowflakeNextIDConcurrency validates the thread-safety of Snowflake's ID generation under concurrent execution.
// It ensures that IDs produced concurrently by multiple goroutines are unique and do not duplicate.
func TestSnowflakeNextIDConcurrency(t *testing.T) {
	sf, err := NewSnowflake(1) // Use a single worker ID for this test
	if err != nil {
		t.Fatalf("failed to create Snowflake: %v", err)
	}

	const goroutines = 10       // Number of concurrent goroutines
	const idsPerGoroutine = 500 // Number of IDs each goroutine will generate
	totalIDs := goroutines * idsPerGoroutine

	// Channel to collect IDs generated by each goroutine
	results := make(chan int64, totalIDs)

	var wg sync.WaitGroup
	wg.Add(goroutines)

	// Launch multiple goroutines to generate IDs concurrently
	for i := 0; i < goroutines; i++ {
		go func() {
			defer wg.Done()
			for j := 0; j < idsPerGoroutine; j++ {
				results <- sf.NextID()
			}
		}()
	}

	wg.Wait()
	close(results)

	// Check all generated IDs for uniqueness
	ids := make(map[int64]struct{})
	for id := range results {
		if _, exists := ids[id]; exists {
			t.Errorf("duplicate ID generated: %d", id)
		} else {
			ids[id] = struct{}{}
		}
	}
}
